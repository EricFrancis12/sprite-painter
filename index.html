<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        #board {
            display: inline-grid;
        }

        .block {
            height: 8px;
            width: 8px;
            border: solid black 1px;
        }

        .block.empty {
            background-color: grey;
        }

        .block.painted {
            background-color: blue;
        }

        .block.outline {
            background-color: black;
        }

        .block.question {
            background-color: red;
        }
    </style>

</head>

<body>
    <diV id="board">

    </diV>

    <script>
        const height = 82;
        const width = 82;
        const padding = 2;

        const boardEle = document.getElementById("board");

        boardEle.style.gridTemplateColumns = `repeat(${width}, 1fr)`;

        const painters = [
            {
                count: 400,
                x: Math.ceil(width / 2),
                y: Math.ceil(height * 2 / 5),
            },
            {
                count: 1400,
                x: Math.ceil(width / 2),
                y: Math.ceil(height / 2),
            },
            {
                count: 400,
                x: Math.ceil(width / 2),
                y: Math.ceil(height * 3 / 5),
            },
        ];

        const dlas = [
            {
                x: Math.ceil(width / 2),
                y: Math.ceil(height * 2 / 5),
                count: 1000,
            },
            {
                x: Math.ceil(width / 2),
                y: Math.ceil(height * 4 / 5),
                count: 1200,
            },
        ];

        const blocks = blocksFromPainters(painters);
        // const blocks = blocksFromDLA(dlas);
        // const blocks = blocksFromCWL(100);

        let symBlocks = blocks.map(row => {
            const newRow = [];
            for (let i = 0; i < Math.ceil(width / 2); i++) {
                newRow.push(row[i - padding]);
            }
            for (let i = 0; i < Math.ceil(width / 2); i++) {
                newRow.push(row.at(-i - Math.ceil(width / 2) - padding - 1));
            }
            return newRow;
        });

        // Fill in empty nested inner blocks
        symBlocks = symBlocks.map((row, y) => row.map((block, x) => {
            if (block === "") {
                let insideCount = 0;

                for (let incr of [1, -1]) {
                    let i = incr;
                    let horizBlock;
                    do {
                        horizBlock = row[x + i];
                        if (horizBlock === "#") {
                            insideCount++;
                            break;
                        }
                        incr === 1 ? i++ : i--;
                    } while (horizBlock !== undefined)

                    let j = incr;
                    let vertBlock;
                    do {
                        vertBlock = symBlocks[y + j]?.[x];
                        if (vertBlock === "#") {
                            insideCount++;
                            break;
                        }
                        incr === 1 ? j++ : j--;
                    } while (vertBlock !== undefined)
                }

                if (insideCount === 4) {
                    return "#";
                }
            }

            return block;
        }));

        // Fill block if both x neighbors or both y neighbors are filled
        for (let y = 0; y < symBlocks.length; y++) {
            const row = symBlocks[y];
            for (let i of [1, -1]) {
                for (let x = 0; x < row.length; x++) {
                    if (row[x] !== "") {
                        continue;
                    }

                    const leftNei = row[x - i];
                    const rightNei = row[x + i];
                    if (leftNei === "#" && rightNei === "#") {
                        symBlocks[y][x] = "#";
                        continue;
                    }

                    const topNei = symBlocks[y + i]?.[x];
                    const bottomNei = symBlocks[y - i]?.[x];
                    if (topNei === "#" && bottomNei === "#") {
                        symBlocks[y][x] = "#";
                    }
                }
                i === 1 ? i++ : i--;
            }
        }

        // Outline shape(s)
        for (let y = 0; y < symBlocks.length; y++) {
            const row = symBlocks[y];
            for (let x = 0; x < row.length; x++) {
                const block = row[x];
                if (block === "#") {
                    for (let i of [1, -1]) {
                        const vertBlock = symBlocks[y + i]?.[x];
                        if (vertBlock === "") {
                            symBlocks[y + i][x] = "o";
                        }

                        const horizBlock = symBlocks[y]?.[x + i];
                        if (horizBlock === "") {
                            symBlocks[y][x + i] = "o";
                        }
                    }
                }
            }
        }

        symBlocks.flat().forEach(block => {
            let blockEle = `<div class="block empty"></div>`;
            if (block === "#") {
                blockEle = `<div class="block painted"></div>`;
            }
            if (block === "o") {
                blockEle = `<div class="block outline"></div>`;
            }
            if (block === "?") {
                blockEle = `<div class="block question"></div>`;
            }

            boardEle.insertAdjacentHTML("beforeend", blockEle);
        });

        function blocksFromPainters(painters) {
            const blocks = makeBlocks();

            for (const painter of painters) {
                while (painter.count >= 0) {
                    blocks[painter.y][painter.x] = "#";

                    const roll = randomIntBetween(1, 4);
                    if (roll === 1 && painter.x > padding) {
                        painter.x -= 1;
                    }
                    if (roll === 2 && painter.x < width - 1 - padding - Math.ceil(width / 2)) {
                        painter.x += 1;
                    }
                    if (roll === 3 && painter.y > padding + 1) {
                        painter.y -= 1;
                    }
                    if (roll === 4 && painter.y < height - 2 - padding) {
                        painter.y += 1;
                    }

                    painter.count -= 1;
                }
            }

            return blocks;
        }

        // Diffusion limited aggregation
        function blocksFromDLA(dlas) {
            const blocks = makeBlocks();

            for (let dla of dlas) {
                if (blocks[dla.y]?.[dla.x] === undefined) {
                    continue;
                }

                blocks[dla.y][dla.x] = "#";

                while (dla.count > 0) {
                    let x = randomIntBetween(padding + 1, height - padding);
                    let y = randomIntBetween(padding + 1, width - padding);

                    if (blocks[y]?.[x] === undefined || blocks[y]?.[x] === "#") {
                        continue;
                    }

                    const touchingFilledBlock = blocks[y + 1]?.[x] === "#" || blocks[y - 1]?.[x] === "#" || blocks[y]?.[x + 1] === "#" || blocks[y]?.[x - 1] === "#";
                    if (touchingFilledBlock) {
                        blocks[y][x] = "#";
                        dla.count--;
                    }
                }
            }

            return blocks;
        }

        // Conway's Game of Life
        function blocksFromCWL(rounds) {
            let blocks = makeBlocks((x, y) => {
                if (x < padding - 1 || x > width - padding + 1 || y < padding + 1 || y > height - padding - 2) {
                    return "";
                }
                return randomIntBetween(0, 1) === 0 ? "" : "#";
            });

            while (rounds > 0) {
                const clone = structuredClone(blocks);

                for (let y = padding + 1; y < height - padding - 1; y++) {
                    const row = [];
                    for (let x = padding + 1; x < width - padding - 1; x++) {
                        if (clone[y]?.[x] === undefined) {
                            continue;
                        }

                        const neis = [
                            clone[y]?.[x + 1],
                            clone[y]?.[x - 1],
                            clone[y - 1]?.[x + 1],
                            clone[y - 1]?.[x - 1],
                            clone[y - 1]?.[x],
                            clone[y + 1]?.[x + 1],
                            clone[y + 1]?.[x - 1],
                            clone[y + 1]?.[x],
                        ];

                        const numBlockNeis = neis.filter(nei => nei === "#").length;

                        if (numBlockNeis === 0) {
                            clone[y][x] = "";
                        } else if (numBlockNeis <= 4) {
                            clone[y][x] = "#";
                        } else {
                            clone[y][x] = "";
                        }

                        blocks = clone;
                    }
                }

                rounds--;
            }

            return blocks;
        }

        function makeBlocks(val = "") {
            const blocks = [];
            for (let y = 0; y < height; y++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    if (typeof val === "function") {
                        row.push(val(x, y));
                    } else {
                        row.push(val);
                    }
                }
                blocks.push(row);
            }
            return blocks;
        }

        function randomIntBetween(min, max) {
            min = Math.floor(min);
            max = Math.ceil(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
    </script>

</body>

</html>